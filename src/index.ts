import 'dotenv/config';
import chalk from 'chalk';

declare global {
  const GSHEETS_API_ENDPOINT: string;
  const CF_API_ENDPOINT: string;
  const DEFAULT_DEST_DOMAIN: string;
  const AUTH_TOKEN: string;
  const GSHEETS_ID: string;
  const GSHEETS_API_KEY: string;
  const CF_ACCT_ID: string; // Really, account TAG
  const CF_LIST_ID: string;
  const CF_API_TOKEN: string;
}

import { checkSpreadsheetStatus, fetchRedirectRows } from './inputs';
import { processSheetRow, ruleInList } from './processing';
import {
  BulkRedirectListItem,
  getBulkListContents,
  getBulkListStatus,
  makeBulkList,
  // uploadBulkList,
} from './outputs';
import { validateBoolean } from './validators';
import { stat } from 'fs';

export type RedirectCode = 301 | 302 | 307 | 308;

/**
 * A validated and sanitized redirect object.
 */
export interface RedirectProps {
  source: string;
  destination: string;
  code: RedirectCode;
  localized: boolean;
  deleted: boolean;
}

/**
 * A raw spreadsheet row that could be a redirect object.
 */
export interface RawRedirectProps {
  source: string;
  destination: string;
  code?: string | number;
  localized?: string | boolean;
  deleted?: string | boolean;
}

/**
 * Work-in-progress, but all responses from this service will be one of these.
 */
export interface DirectomaticResponse {
  success?: boolean; // If an action was requested
  errors?: any[]; // Error messages either from CF or from this code
  messages?: any[]; // This would be from the CF API
  inputRules?: RedirectProps[];
  invalidRules?: BulkRedirectListItem[] | RawRedirectProps[];
}

// @TODO: Full listing for cf.com but this should be configurable. Move to env var?
export const Locales = [
  'de-de',
  'en-au',
  'en-ca',
  'en-gb',
  'en-in',
  'en-us',
  'es-es',
  'fr-fr',
  'id-id',
  'it-it',
  'ja-jp',
  'ko-kr',
  'nl-nl',
  'pt-br',
  'ru-ru',
  'sv-se',
  'th-th',
  'tr-tr',
  'vi-vn',
  'zh-cn',
  'zh-hans-cn',
  'zh-tw',
];

const arg = process.argv[2] || false;

// @TODO: VALIDATE ENV
console.log(chalk.blue("Checking environment..."));


/**
 * GET /status
 *
 * Confirm that we can read the Google Sheet and the Rules Lists.
 */
const status = async () => {
  const sheet = await checkSpreadsheetStatus();
  const cflist = await getBulkListStatus();

  console.log(
    JSON.stringify({
      success: sheet.success && cflist.success,
      errors: [sheet.errors, cflist.errors].flat(),
      messages: [sheet.messages, cflist.messages].flat(),
    })
  );
}
if (arg === 'status') {
  status();
}

/**
 * GET /list
 *
 * Show a list of all the redirects that would be generated by the spreadsheet
 * and report a list of any that fail OUR validation, returning the raw data.
 */
const list = async () => {
  // Source the unprocessed redirects list from the Google Sheet.
  const inputRows = await fetchRedirectRows();

  // Sanitize, validate, and clean up the input; skim off the bad rows to report.
  const badRows: RawRedirectProps[] = [];
  const redirectsList = inputRows.flatMap((row) => {
    const output = processSheetRow(row);
    if (output) {
      return output;
    } else {
      // If the row was skipped because it was _deleted_, don't include it in
      // the error report output.
      if (!validateBoolean(row.deleted, false)) {
        badRows.push(row);
      }

      // Return empty, which will :magic: away in flatMap() and won't be uploaded.
      return [];
    }
  });

  console.log(
    JSON.stringify({
      messages: [
        `Google sheet contains ${redirectsList.length} valid rules and ${badRows.length} rows with errors.`,
      ],
      inputRows: redirectsList,
      invalidRules: badRows,
      // duplicateRules: duplicates,
    })
  );
};

/**
 * GET /diff
 *
 * Pull and process the redirects from the spreadsheet to report on what will be
 * added and what will be removed on a subsequent /publish.
 */
const diff = async () => {
  // Source the unprocessed redirects list from the Google Sheet.
  const inputRows = await fetchRedirectRows();

  // Sanitize, validate, to make the final list
  const redirectsList = inputRows.flatMap((row) => {
    return processSheetRow(row) ?? [];
  });

  // Format as needed for the Cloudflare Ruleset API
  const spreadsheetList = makeBulkList(redirectsList);

  // Get the current list
  const cloudflareList = await getBulkListContents();

  // We need to see what cloudflareList rules aren't in spreadsheetList
  const removedRules = cloudflareList.filter((rule) => {
    return !ruleInList(rule, spreadsheetList);
  });

  // We need to see what spreadsheetList rules aren't in cloudflareList
  const addedRules = spreadsheetList.filter((rule) => {
    return !ruleInList(rule, cloudflareList);
  });

  console.log(
    JSON.stringify({
      messages: [
        [
          `There are ${addedRules.length} rules to add (in spreadsheet but not published).`,
        ],
        [
          `There are ${removedRules.length} rules to remove (published but not in spreadsheet).`,
        ],
        { addedRules },
        { removedRules },
      ],
    })
  );
};

/**
 * GET /publish
 *
 * Fetch redirects from the Google Sheet, sanitize/validate, prep the "good" ones
 * for the Cloudflare Ruleset API, and replace the list with the new set. Report
 * on any errors from Cloudflare and note any redirects that the API rejected.
 */
const publish = async () => {
  // Source the unprocessed redirects list from the Google Sheet.
  const inputRows = await fetchRedirectRows();

  // Sanitize, validate, to make the final list
  const redirectsList = inputRows.flatMap((row) => {
    return processSheetRow(row) ?? [];
  });

  // Format as needed for the Cloudflare Ruleset API
  const bulkList = makeBulkList(redirectsList);

  // Send the processed list to CF
  // const uploadResponse = await uploadBulkList(bulkList);

  console.log(JSON.stringify(bulkList));
};

switch (arg) {
  case "status":
    status();

}
